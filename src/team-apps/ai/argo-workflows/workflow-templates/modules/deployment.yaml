apiVersion: argoproj.io/v1alpha1
kind: WorkflowTemplate
metadata:
  name: deployment-templates
  namespace: ai
spec:
  serviceAccountName: workflow-executor

  templates:
  # - name: reload-ray-serve
  #   inputs:
  #     parameters:
  #     - name: model_name
  #     - name: prod_version
  #     - name: ray_service_namespace
  #       value: "ai"
  #   script:
  #     image: alpine:latest
  #     command: [sh]
  #     source: |
  #       set -e
  #       apk add --no-cache curl jq

  #       MODEL_NAME="{{inputs.parameters.model_name}}"
  #       PROD_VERSION="{{inputs.parameters.prod_version}}"
  #       NAMESPACE="ai"
  #       SERVICE_NAME="${MODEL_NAME}-service"
  #       APP_NAME="${MODEL_NAME}-api"

  #       echo "üîÑ Deploying model version ${PROD_VERSION}"

  #       RAY_DASHBOARD="http://${SERVICE_NAME}-head-svc.${NAMESPACE}.svc.cluster.local:8265"
  #       NEW_MODEL_URI="models:/prod.${MODEL_NAME}/${PROD_VERSION}"

  #       # Check if Ray Serve is available
  #       if ! curl -sf "${RAY_DASHBOARD}/api/serve/applications/" > /dev/null 2>&1; then
  #         echo "‚ùå Ray Serve not available at ${RAY_DASHBOARD}"
  #         echo "   Service may not be running yet"
  #         exit 1
  #       fi

  #       # Get current deployed config
  #       echo "üì• Checking current deployment status..."
  #       curl -s "${RAY_DASHBOARD}/api/serve/applications/" > /tmp/current.json

  #       APP_STATUS=$(cat /tmp/current.json | jq -r ".applications[\"${APP_NAME}\"].status // \"NOT_FOUND\"")

  #       if [ "$APP_STATUS" = "NOT_FOUND" ]; then
  #         echo "üÜï First deployment - creating application config..."

  #         # Determine deployment class name based on model
  #         DEPLOYMENT_CLASS="WineClassifier"
  #         NUM_CPUS="0.5"

  #         if echo "$MODEL_NAME" | grep -q "fashion-mnist"; then
  #           DEPLOYMENT_CLASS="FashionMNISTClassifier"
  #           NUM_CPUS="1"
  #         fi

  #         # Create full application config for first deployment
  #         jq -n \
  #           --arg name "$APP_NAME" \
  #           --arg import_path "src.serve:app_builder" \
  #           --arg route_prefix "/models/${MODEL_NAME}" \
  #           --arg deployment_name "$DEPLOYMENT_CLASS" \
  #           --arg model_uri "$NEW_MODEL_URI" \
  #           --arg num_cpus "$NUM_CPUS" \
  #           '{
  #             applications: [{
  #               name: $name,
  #               import_path: $import_path,
  #               route_prefix: $route_prefix,
  #               deployments: [{
  #                 name: $deployment_name,
  #                 num_replicas: 1,
  #                 user_config: {
  #                   model_uri: $model_uri
  #                 },
  #                 ray_actor_options: {
  #                   num_cpus: ($num_cpus | tonumber)
  #                 }
  #               }]
  #             }]
  #           }' > /tmp/payload.json
  #       else
  #         echo "üîÑ Updating existing deployment..."

  #         # Get deployed config
  #         APP_CONFIG=$(cat /tmp/current.json | jq ".applications[\"${APP_NAME}\"].deployed_app_config")

  #         if [ "$APP_CONFIG" = "null" ]; then
  #           echo "‚ùå Application exists but has no deployed_app_config"
  #           exit 1
  #         fi

  #         # Update model_uri in the config
  #         echo "$APP_CONFIG" | jq \
  #           --arg uri "$NEW_MODEL_URI" \
  #           '.deployments[0].user_config.model_uri = $uri' \
  #           > /tmp/updated_app.json

  #         # Wrap in applications array
  #         jq -n \
  #           --argjson app "$(cat /tmp/updated_app.json)" \
  #           '{applications: [$app]}' \
  #           > /tmp/payload.json
  #       fi

  #       echo ""
  #       echo "üöÄ Deploying configuration..."
  #       cat /tmp/payload.json | jq '.'

  #       RESPONSE=$(curl -X PUT "${RAY_DASHBOARD}/api/serve/applications/" \
  #         -H "Content-Type: application/json" \
  #         -d @/tmp/payload.json \
  #         -w "\n%{http_code}" -s)

  #       HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
  #       BODY=$(echo "$RESPONSE" | head -n-1)

  #       if [ "$HTTP_CODE" = "200" ]; then
  #         echo "‚úÖ Model deployed to version ${PROD_VERSION}!"
  #         echo "   Model URI: ${NEW_MODEL_URI}"
  #         if [ "$APP_STATUS" = "NOT_FOUND" ]; then
  #           echo "   Initial deployment - application created"
  #         else
  #           echo "   reconfigure() method will be called with new model"
  #         fi
  #       else
  #         echo "‚ùå Failed (HTTP ${HTTP_CODE})"
  #         echo "$BODY"
  #         exit 1
  #       fi
  - name: reload-ray-serve
    inputs:
      parameters:
      - name: model_name
      - name: prod_version
      - name: training_image  # Add this
    script:
      image: bitnami/kubectl:latest
      command: [sh]
      source: |
        set -e

        MODEL_NAME="{{inputs.parameters.model_name}}"
        PROD_VERSION="{{inputs.parameters.prod_version}}"
        TRAINING_IMAGE="{{inputs.parameters.training_image}}"
        NAMESPACE="ai"
        SERVICE_NAME="${MODEL_NAME}-service"

        echo "üîÑ Updating Ray Serve with new model and image"
        echo "   Model: prod.${MODEL_NAME}/v${PROD_VERSION}"
        echo "   Image: ${TRAINING_IMAGE}"

        # Update RayService image if it changed
        CURRENT_IMAGE=$(kubectl get rayservice ${SERVICE_NAME} -n ${NAMESPACE} -o jsonpath='{.spec.rayClusterConfig.headGroupSpec.template.spec.containers[0].image}')

        if [ "$CURRENT_IMAGE" != "$TRAINING_IMAGE" ]; then
          echo "üì¶ Image changed: ${CURRENT_IMAGE} ‚Üí ${TRAINING_IMAGE}"
          echo "   Updating RayService..."

          # Update both head and worker images
          kubectl patch rayservice ${SERVICE_NAME} -n ${NAMESPACE} --type=json -p='[
            {"op": "replace", "path": "/spec/rayClusterConfig/headGroupSpec/template/spec/containers/0/image", "value": "'${TRAINING_IMAGE}'"},
            {"op": "replace", "path": "/spec/rayClusterConfig/workerGroupSpecs/0/template/spec/containers/0/image", "value": "'${TRAINING_IMAGE}'"}
          ]'

          echo "‚è≥ Waiting for rollout to complete (this will restart Ray)..."
          kubectl rollout status deployment/${SERVICE_NAME}-head-svc -n ${NAMESPACE} --timeout=300s || true
        else
          echo "‚úÖ Image unchanged, proceeding with in-place model update"
        fi

        # Now update the model URI via Ray Serve API (in-place)
        RAY_DASHBOARD="http://${SERVICE_NAME}-head-svc.${NAMESPACE}.svc.cluster.local:8265"
        NEW_MODEL_URI="models:/prod.${MODEL_NAME}/${PROD_VERSION}"

        # Wait for Ray Dashboard to be available
        MAX_WAIT=120
        ELAPSED=0
        while [ $ELAPSED -lt $MAX_WAIT ]; do
          if curl -sf "${RAY_DASHBOARD}/api/serve/applications/" > /dev/null 2>&1; then
            echo "‚úÖ Ray Dashboard available"
            break
          fi
          echo "‚è≥ Waiting for Ray Dashboard..."
          sleep 5
          ELAPSED=$((ELAPSED + 5))
        done

        if [ $ELAPSED -ge $MAX_WAIT ]; then
          echo "‚ùå Ray Dashboard not available"
          exit 1
        fi

        # Update model via API (rest of your existing logic)
        apk add --no-cache curl jq

        curl -s "${RAY_DASHBOARD}/api/serve/applications/" > /tmp/current.json
        APP_NAME="${MODEL_NAME}-api"
        APP_CONFIG=$(cat /tmp/current.json | jq ".applications[\"${APP_NAME}\"].deployed_app_config")

        if [ "$APP_CONFIG" = "null" ]; then
          echo "‚ùå Application not deployed yet"
          exit 1
        fi

        echo "$APP_CONFIG" | jq --arg uri "$NEW_MODEL_URI" '.deployments[0].user_config.model_uri = $uri' > /tmp/updated_app.json
        jq -n --argjson app "$(cat /tmp/updated_app.json)" '{applications: [$app]}' > /tmp/payload.json

        echo "üöÄ Updating model URI..."
        RESPONSE=$(curl -X PUT "${RAY_DASHBOARD}/api/serve/applications/" \
          -H "Content-Type: application/json" \
          -d @/tmp/payload.json \
          -w "\n%{http_code}" -s)

        HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
        if [ "$HTTP_CODE" = "200" ]; then
          echo "‚úÖ Model deployed to version ${PROD_VERSION}!"
        else
          echo "‚ùå Failed (HTTP ${HTTP_CODE})"
          exit 1
        fi
