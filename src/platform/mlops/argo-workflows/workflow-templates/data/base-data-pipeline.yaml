apiVersion: argoproj.io/v1alpha1
kind: WorkflowTemplate
metadata:
  name: data-pipeline
  namespace: mlops
  annotations:
    # workflows.argoproj.io/title: '**Data Pipeline**'
    # workflows.argoproj.io/description: "Run DVC data pipelines with automatic versioning"
spec:
  serviceAccountName: workflow-executor

  arguments:
    parameters:
      - name: pipelines
        description: "JSON array of pipeline names to run"
        value: '["opencloudhub-readmes-download"]'
      - name: force
        description: "Force re-run even if no changes"
        value: "false"
      - name: bump_type
        description: "Version bump type: major, minor, patch"
        value: "patch"
      - name: is_automated
        description: "Add -automated suffix to tags"
        value: "false"
      - name: image
        description: "Docker image for DVC operations"
        value: "opencloudhuborg/data-registry-pipelines:latest"

  entrypoint: main

  templates:
    # --------------------------------------------------------------------------
    # Main: fan out to run each pipeline in parallel
    # --------------------------------------------------------------------------
    - name: main
      steps:
        - - name: run-pipeline
            template: single-pipeline
            arguments:
              parameters:
                - name: pipeline_name
                  value: "{{item}}"
            withParam: "{{workflow.parameters.pipelines}}"

    # --------------------------------------------------------------------------
    # Single pipeline: clone, run, push, commit, tag - all in one container
    # --------------------------------------------------------------------------
    - name: single-pipeline
      inputs:
        parameters:
          - name: pipeline_name
      outputs:
        parameters:
          - name: tag
            valueFrom:
              path: /tmp/outputs/tag.txt
          - name: changed
            valueFrom:
              path: /tmp/outputs/changed.txt
      volumes:
        - name: git-secret
          secret:
            secretName: data-registry-repo
      script:
        image: "{{workflow.parameters.image}}"
        command: [bash]
        volumeMounts:
          - name: git-secret
            mountPath: /mnt/secrets
            readOnly: true
        env:
          - name: AWS_ACCESS_KEY_ID
            valueFrom:
              secretKeyRef:
                name: minio-tenant-secret
                key: accesskey
          - name: AWS_SECRET_ACCESS_KEY
            valueFrom:
              secretKeyRef:
                name: minio-tenant-secret
                key: secretkey
          - name: AWS_ENDPOINT_URL
            valueFrom:
              secretKeyRef:
                name: minio-tenant-secret
                key: endpoint-url
        resources:
          requests:
            cpu: "2"
            memory: "4Gi"
          limits:
            cpu: "4"
            memory: "8Gi"
        source: |
          set -e

          PIPELINE="{{inputs.parameters.pipeline_name}}"
          FORCE="{{workflow.parameters.force}}"
          BUMP_TYPE="{{workflow.parameters.bump_type}}"
          IS_AUTOMATED="{{workflow.parameters.is_automated}}"

          # Initialize outputs
          mkdir -p /tmp/outputs
          echo "" > /tmp/outputs/tag.txt
          echo "false" > /tmp/outputs/changed.txt

          echo "════════════════════════════════════════════════════════════"
          echo "🚀 Pipeline: $PIPELINE"
          echo "════════════════════════════════════════════════════════════"

          # Setup SSH
          mkdir -p ~/.ssh
          cat /mnt/secrets/sshPrivateKey > ~/.ssh/id_ed25519
          echo "" >> ~/.ssh/id_ed25519
          chmod 600 ~/.ssh/id_ed25519
          ssh-keyscan github.com >> ~/.ssh/known_hosts 2>/dev/null

          # Clone
          echo "📥 Cloning..."
          git clone git@github.com:OpenCloudHub/data-registry.git /tmp/repo
          cd /tmp/repo
          git config user.name "Argo Workflow"
          git config user.email "workflow@opencloudhub.org"

          # Configure DVC
          dvc remote modify minio endpointurl "$AWS_ENDPOINT_URL"
          dvc remote modify minio access_key_id "$AWS_ACCESS_KEY_ID"
          dvc remote modify minio secret_access_key "$AWS_SECRET_ACCESS_KEY"

          # Hash before
          LOCK_FILE="pipelines/${PIPELINE}/dvc.lock"
          HASH_BEFORE="none"
          [ -f "$LOCK_FILE" ] && HASH_BEFORE=$(md5sum "$LOCK_FILE" | cut -d' ' -f1)

          # Run DVC
          echo "🔄 Running DVC..."
          FORCE_FLAG=""
          [ "$FORCE" = "true" ] && FORCE_FLAG="--force" && echo "⚠️ Force mode"
          dvc repro $FORCE_FLAG "pipelines/${PIPELINE}/dvc.yaml"

          # Push data
          echo "📤 Pushing data..."
          dvc push

          # Check if changed
          HASH_AFTER="none"
          [ -f "$LOCK_FILE" ] && HASH_AFTER=$(md5sum "$LOCK_FILE" | cut -d' ' -f1)

          if [ "$HASH_BEFORE" = "$HASH_AFTER" ]; then
            echo "✅ No changes"
            exit 0
          fi

          echo "true" > /tmp/outputs/changed.txt
          echo "📝 dvc.lock changed"

          # Commit with retry
          git add "pipelines/${PIPELINE}/"
          git commit -m "chore(${PIPELINE}): update dvc.lock [skip ci]"

          for attempt in 1 2 3; do
            echo "🔄 Push attempt $attempt..."
            if git push origin main; then
              echo "✅ Pushed"
              break
            fi
            if [ $attempt -eq 3 ]; then
              echo "❌ Failed after 3 attempts"
              exit 1
            fi
            echo "⚠️ Conflict, rebasing..."
            git pull --rebase origin main
          done

          # Create tag
          [ "$IS_AUTOMATED" = "true" ] && SUFFIX="-automated" || SUFFIX=""

          LATEST=$(git tag -l "${PIPELINE}-v*" --sort=-version:refname | head -n1 || echo "")
          if [ -z "$LATEST" ]; then
            VERSION="1.0.0"
          else
            CURRENT=$(echo "$LATEST" | sed "s/${PIPELINE}-v//" | sed 's/-automated//')
            MAJOR=$(echo "$CURRENT" | cut -d. -f1)
            MINOR=$(echo "$CURRENT" | cut -d. -f2)
            PATCH=$(echo "$CURRENT" | cut -d. -f3)
            case "$BUMP_TYPE" in
              major) VERSION="$((MAJOR + 1)).0.0" ;;
              minor) VERSION="${MAJOR}.$((MINOR + 1)).0" ;;
              *) VERSION="${MAJOR}.${MINOR}.$((PATCH + 1))" ;;
            esac
          fi

          NEW_TAG="${PIPELINE}-v${VERSION}${SUFFIX}"

          if git tag -l "$NEW_TAG" | grep -q .; then
            echo "ℹ️ Tag $NEW_TAG exists"
          else
            git tag -a "$NEW_TAG" -m "${PIPELINE} v${VERSION}"
            git push origin "$NEW_TAG"
            echo "🏷️ Created: $NEW_TAG"
          fi

          echo "$NEW_TAG" > /tmp/outputs/tag.txt

          echo "════════════════════════════════════════════════════════════"
          echo "✅ Complete: $NEW_TAG"
          echo "════════════════════════════════════════════════════════════"
