apiVersion: argoproj.io/v1alpha1
kind: WorkflowTemplate
metadata:
  name: embeddings-pipeline
  namespace: mlops
  annotations:
    workflows.argoproj.io/description: "Run embeddings generation via Ray with automatic versioning"
spec:
  serviceAccountName: workflow-executor

  arguments:
    parameters:
      - name: data_version
        description: "DVC data version tag (e.g., opencloudhub-readmes-v1.0.0)"
      - name: force
        value: "false"
        description: "Force re-run even if no changes"
      - name: compute_type
        value: "cpu-medium"
        enum: [cpu-small, cpu-medium, cpu-large, gpu-small, gpu-medium, gpu-large]
        description: "Compute configuration"
      - name: image
        description: "Docker image for embeddings"
        value: "opencloudhuborg/data-registry-pipelines:latest"
      - name: bump_type
        value: "patch"
        description: "Version bump type: major, minor, patch"
      - name: is_automated
        value: "false"
        description: "Add -automated suffix to tags"

  entrypoint: main

  templates:
    - name: main
      steps:
        - - name: map-compute
            templateRef:
              name: compute-templates
              template: map-compute-config
            arguments:
              parameters:
                - name: compute_type
                  value: "{{workflow.parameters.compute_type}}"

        - - name: run-embeddings
            template: submit-ray-embeddings
            arguments:
              parameters:
                - name: data_version
                  value: "{{workflow.parameters.data_version}}"
                - name: force
                  value: "{{workflow.parameters.force}}"
                - name: image
                  value: "{{workflow.parameters.image}}"
                - name: cpu_request
                  value: "{{steps.map-compute.outputs.parameters.cpu_request}}"
                - name: cpu_limit
                  value: "{{steps.map-compute.outputs.parameters.cpu_limit}}"
                - name: memory_request
                  value: "{{steps.map-compute.outputs.parameters.memory_request}}"
                - name: memory_limit
                  value: "{{steps.map-compute.outputs.parameters.memory_limit}}"
                - name: replicas
                  value: "{{steps.map-compute.outputs.parameters.replicas}}"
                - name: gpu
                  value: "{{steps.map-compute.outputs.parameters.gpu}}"

        - - name: commit-and-tag
            template: git-commit-tag
            arguments:
              parameters:
                - name: data_version
                  value: "{{workflow.parameters.data_version}}"
                - name: bump_type
                  value: "{{workflow.parameters.bump_type}}"
                - name: is_automated
                  value: "{{workflow.parameters.is_automated}}"

    - name: submit-ray-embeddings
      inputs:
        parameters:
          - name: data_version
          - name: force
          - name: image
          - name: cpu_request
          - name: cpu_limit
          - name: memory_request
          - name: memory_limit
          - name: replicas
          - name: gpu
      outputs:
        parameters:
          - name: job-name
            valueFrom:
              path: /tmp/job-name.txt
      script:
        image: bitnami/kubectl:latest
        command: [bash]
        source: |
          set -e

          DATA_VERSION="{{inputs.parameters.data_version}}"
          FORCE="{{inputs.parameters.force}}"
          IMAGE="{{inputs.parameters.image}}"
          CPU_REQUEST="{{inputs.parameters.cpu_request}}"
          CPU_LIMIT="{{inputs.parameters.cpu_limit}}"
          MEMORY_REQUEST="{{inputs.parameters.memory_request}}"
          MEMORY_LIMIT="{{inputs.parameters.memory_limit}}"
          REPLICAS="{{inputs.parameters.replicas}}"
          GPU="{{inputs.parameters.gpu}}"
          WORKFLOW_UID="{{workflow.uid}}"

          TIMESTAMP=$(date +%Y%m%d-%H%M%S)

          FORCE_FLAG=""
          [ "$FORCE" = "true" ] && FORCE_FLAG="--force"

          RUN_LABEL="embeddings-${TIMESTAMP}"

          echo "Creating RayJob for embeddings"
          echo "  Label: workflow-run=${RUN_LABEL}"
          echo "  Data version: ${DATA_VERSION}"
          echo "  Force: ${FORCE_FLAG:-none}"

          # Build the entrypoint command
          ENTRYPOINT="sed -i s/version:.*/version:\ ${DATA_VERSION}/ pipelines/opencloudhub-readmes-embeddings/params.yaml && dvc repro ${FORCE_FLAG} pipelines/opencloudhub-readmes-embeddings/dvc.yaml"

          # Write RayJob YAML to file to avoid heredoc escaping issues
          cat > /tmp/rayjob.yaml << 'YAMLEOF'
          apiVersion: ray.io/v1
          kind: RayJob
          metadata:
            generateName: embeddings-
            namespace: mlops
          spec:
            shutdownAfterJobFinishes: true
            ttlSecondsAfterFinished: 300
            rayClusterSpec:
              rayVersion: "2.51.0"
              headGroupSpec:
                serviceType: ClusterIP
                template:
                  spec:
                    containers:
                    - name: ray-head
                      resources:
                        requests:
                          cpu: "PLACEHOLDER_CPU_REQUEST"
                          memory: "PLACEHOLDER_MEMORY_REQUEST"
                        limits:
                          cpu: "PLACEHOLDER_CPU_LIMIT"
                          memory: "PLACEHOLDER_MEMORY_LIMIT"
                      env:
                      - name: AWS_ACCESS_KEY_ID
                        valueFrom:
                          secretKeyRef:
                            name: minio-tenant-secret
                            key: accesskey
                      - name: AWS_SECRET_ACCESS_KEY
                        valueFrom:
                          secretKeyRef:
                            name: minio-tenant-secret
                            key: secretkey
                      - name: AWS_ENDPOINT_URL
                        valueFrom:
                          secretKeyRef:
                            name: minio-tenant-secret
                            key: endpoint-url
                      - name: PGVECTOR_HOST
                        value: cnpg-cluster-rw.storage.svc.cluster.local
                      - name: POSTGRES_DEMO_APP_DB_PASSWORD
                        valueFrom:
                          secretKeyRef:
                            name: demo-app-db-user
                            key: password
              workerGroupSpecs:
              - replicas: PLACEHOLDER_REPLICAS
                groupName: worker
                template:
                  spec:
                    containers:
                    - name: ray-worker
                      resources:
                        requests:
                          cpu: "PLACEHOLDER_CPU_REQUEST"
                          memory: "PLACEHOLDER_MEMORY_REQUEST"
                        limits:
                          cpu: "PLACEHOLDER_CPU_LIMIT"
                          memory: "PLACEHOLDER_MEMORY_LIMIT"
                      env:
                      - name: AWS_ACCESS_KEY_ID
                        valueFrom:
                          secretKeyRef:
                            name: minio-tenant-secret
                            key: accesskey
                      - name: AWS_SECRET_ACCESS_KEY
                        valueFrom:
                          secretKeyRef:
                            name: minio-tenant-secret
                            key: secretkey
                      - name: AWS_ENDPOINT_URL
                        valueFrom:
                          secretKeyRef:
                            name: minio-tenant-secret
                            key: endpoint-url
                      - name: PGVECTOR_HOST
                        value: cnpg-cluster-rw.storage.svc.cluster.local
                      - name: POSTGRES_DEMO_APP_DB_PASSWORD
                        valueFrom:
                          secretKeyRef:
                            name: demo-app-db-user
                            key: password
          YAMLEOF

          # Now use sed to replace placeholders with actual values
          sed -i "s|PLACEHOLDER_CPU_REQUEST|${CPU_REQUEST}|g" /tmp/rayjob.yaml
          sed -i "s|PLACEHOLDER_CPU_LIMIT|${CPU_LIMIT}|g" /tmp/rayjob.yaml
          sed -i "s|PLACEHOLDER_MEMORY_REQUEST|${MEMORY_REQUEST}|g" /tmp/rayjob.yaml
          sed -i "s|PLACEHOLDER_MEMORY_LIMIT|${MEMORY_LIMIT}|g" /tmp/rayjob.yaml
          sed -i "s|PLACEHOLDER_REPLICAS|${REPLICAS}|g" /tmp/rayjob.yaml

          # Add dynamic fields using yq or just more sed
          # Add labels
          sed -i "s|metadata:|metadata:\n    labels:\n      workflow-run: \"${RUN_LABEL}\"\n      pipeline: \"embeddings\"|" /tmp/rayjob.yaml

          # Add image to both containers
          sed -i "s|name: ray-head|name: ray-head\n                      image: ${IMAGE}|" /tmp/rayjob.yaml
          sed -i "s|name: ray-worker|name: ray-worker\n                      image: ${IMAGE}|" /tmp/rayjob.yaml

          # Add entrypoint and runtimeEnvYAML
          sed -i "s|spec:\n            shutdownAfterJobFinishes|spec:\n            entrypoint: \"${ENTRYPOINT}\"\n            runtimeEnvYAML: \"working_dir: /workspace/project\"\n            shutdownAfterJobFinishes|" /tmp/rayjob.yaml

          # Debug: show the YAML
          echo "=== Generated RayJob YAML ==="
          cat /tmp/rayjob.yaml
          echo "=== End YAML ==="

          # Apply the YAML
          kubectl create -f /tmp/rayjob.yaml

          echo "⏳ Waiting for RayJob..."
          sleep 3

          JOB_NAME=$(kubectl get rayjobs -n mlops -l workflow-run="${RUN_LABEL}" -o jsonpath='{.items[0].metadata.name}')

          if [ -z "$JOB_NAME" ]; then
            echo "❌ Failed to get RayJob"
            exit 1
          fi

          echo "✅ RayJob: $JOB_NAME"
          echo "$JOB_NAME" > /tmp/job-name.txt

          echo "⏳ Waiting for job to be submitted..."

          MAX_WAIT=1200
          ELAPSED=0

          while [ $ELAPSED -lt $MAX_WAIT ]; do
            JOB_DEPLOYMENT_STATUS=$(kubectl get rayjob -n mlops $JOB_NAME -o jsonpath='{.status.jobDeploymentStatus}')

            if [ "$JOB_DEPLOYMENT_STATUS" = "Running" ] || [ "$JOB_DEPLOYMENT_STATUS" = "Complete" ]; then
              echo "✅ Job submitted successfully"
              break
            fi

            sleep 5
            ELAPSED=$((ELAPSED + 5))
          done

          if [ $ELAPSED -ge $MAX_WAIT ]; then
            echo "❌ Job submission timeout after ${MAX_WAIT}s"
            kubectl describe rayjob -n mlops $JOB_NAME
            exit 1
          fi

          SUBMITTER_POD=$(kubectl get pods -n mlops -l ray.io/is-ray-node!=yes | grep ${JOB_NAME} | awk '{print $1}' | head -n1)

          echo "✅ Submitter pod: $SUBMITTER_POD"
          kubectl wait --for=condition=Ready pod/$SUBMITTER_POD -n mlops --timeout=300s || true

          echo ""
          echo "🔍 Streaming embeddings logs..."
          echo "================================"

          kubectl logs -n mlops $SUBMITTER_POD -f 2>/dev/null &
          LOG_PID=$!

          while true; do
            STATUS=$(kubectl get rayjob -n mlops $JOB_NAME -o jsonpath='{.status.jobStatus}' 2>/dev/null)

            if [ -z "$STATUS" ]; then
              sleep 10
              continue
            fi

            case "$STATUS" in
              "SUCCEEDED")
                sleep 5
                kill $LOG_PID 2>/dev/null || true
                wait $LOG_PID 2>/dev/null || true
                echo ""
                echo "✅ Embeddings complete!"
                exit 0
                ;;
              "FAILED"|"STOPPED")
                kill $LOG_PID 2>/dev/null || true
                wait $LOG_PID 2>/dev/null || true
                echo ""
                echo "❌ Embeddings failed: $STATUS"
                kubectl describe rayjob -n mlops $JOB_NAME
                exit 1
                ;;
              *)
                sleep 10
                ;;
            esac
          done

    - name: git-commit-tag
      inputs:
        parameters:
          - name: data_version
          - name: bump_type
          - name: is_automated
      outputs:
        parameters:
          - name: tag
            valueFrom:
              path: /tmp/tag.txt
      volumes:
        - name: git-secret
          secret:
            secretName: data-registry-repo
      script:
        image: alpine/git:latest
        command: [sh]
        volumeMounts:
          - name: git-secret
            mountPath: /mnt/secrets
            readOnly: true
        source: |
          set -e
          echo "" > /tmp/tag.txt

          DATA_VERSION="{{inputs.parameters.data_version}}"
          BUMP_TYPE="{{inputs.parameters.bump_type}}"
          IS_AUTOMATED="{{inputs.parameters.is_automated}}"
          TAG_PREFIX="opencloudhub-readmes-embeddings"

          mkdir -p ~/.ssh
          cat /mnt/secrets/sshPrivateKey > ~/.ssh/id_ed25519
          echo "" >> ~/.ssh/id_ed25519
          chmod 600 ~/.ssh/id_ed25519
          ssh-keyscan github.com >> ~/.ssh/known_hosts 2>/dev/null

          echo "📥 Cloning..."
          git clone git@github.com:OpenCloudHub/data-registry.git /tmp/repo
          cd /tmp/repo
          git config user.name "Argo Workflow"
          git config user.email "workflow@opencloudhub.org"

          [ "$IS_AUTOMATED" = "true" ] && SUFFIX="-automated" || SUFFIX=""

          LATEST=$(git tag -l "${TAG_PREFIX}-v*" --sort=-version:refname | head -n1 || echo "")
          if [ -z "$LATEST" ]; then
            VERSION="1.0.0"
          else
            CURRENT=$(echo "$LATEST" | sed "s/${TAG_PREFIX}-v//" | sed 's/-automated//')
            MAJOR=$(echo "$CURRENT" | cut -d. -f1)
            MINOR=$(echo "$CURRENT" | cut -d. -f2)
            PATCH=$(echo "$CURRENT" | cut -d. -f3)
            case "$BUMP_TYPE" in
              major) VERSION="$((MAJOR + 1)).0.0" ;;
              minor) VERSION="${MAJOR}.$((MINOR + 1)).0" ;;
              *) VERSION="${MAJOR}.${MINOR}.$((PATCH + 1))" ;;
            esac
          fi

          NEW_TAG="${TAG_PREFIX}-v${VERSION}${SUFFIX}"

          if git tag -l "$NEW_TAG" | grep -q .; then
            echo "ℹ️ Tag $NEW_TAG exists"
          else
            git tag -a "$NEW_TAG" -m "Embeddings v${VERSION} (source: ${DATA_VERSION})"
            git push origin "$NEW_TAG"
            echo "🏷️ Created: $NEW_TAG"
          fi

          echo "$NEW_TAG" > /tmp/tag.txt

          echo "════════════════════════════════════════════════════════════"
          echo "✅ Complete"
          echo "   Source data: $DATA_VERSION"
          echo "   Embeddings:  $NEW_TAG"
          echo "════════════════════════════════════════════════════════════"
