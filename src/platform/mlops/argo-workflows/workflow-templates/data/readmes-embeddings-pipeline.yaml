apiVersion: argoproj.io/v1alpha1
kind: WorkflowTemplate
metadata:
  name: embeddings-pipeline
  namespace: mlops
spec:
  serviceAccountName: workflow-executor

  arguments:
    parameters:
      - name: data_version
      - name: force
        value: "false"
      - name: compute_type
        value: "cpu-medium"
      - name: image
        value: "opencloudhuborg/data-registry-pipelines:latest"
      - name: bump_type
        value: "patch"
      - name: is_automated
        value: "false"

  entrypoint: main

  templates:
    - name: main
      steps:
        - - name: map-compute
            templateRef:
              name: compute-templates
              template: map-compute-config
            arguments:
              parameters:
                - name: compute_type
                  value: "{{workflow.parameters.compute_type}}"

        - - name: run-embeddings
            template: submit-ray-embeddings
            arguments:
              parameters:
                - name: data_version
                  value: "{{workflow.parameters.data_version}}"
                - name: force
                  value: "{{workflow.parameters.force}}"
                - name: image
                  value: "{{workflow.parameters.image}}"
                - name: cpu_request
                  value: "{{steps.map-compute.outputs.parameters.cpu_request}}"
                - name: cpu_limit
                  value: "{{steps.map-compute.outputs.parameters.cpu_limit}}"
                - name: memory_request
                  value: "{{steps.map-compute.outputs.parameters.memory_request}}"
                - name: memory_limit
                  value: "{{steps.map-compute.outputs.parameters.memory_limit}}"
                - name: replicas
                  value: "{{steps.map-compute.outputs.parameters.replicas}}"

        - - name: commit-and-tag
            template: git-commit-tag
            when: "{{steps.run-embeddings.exitCode}} == 0"
            arguments:
              parameters:
                - name: data_version
                  value: "{{workflow.parameters.data_version}}"
                - name: bump_type
                  value: "{{workflow.parameters.bump_type}}"
                - name: is_automated
                  value: "{{workflow.parameters.is_automated}}"

    - name: submit-ray-embeddings
      inputs:
        parameters:
          - name: data_version
          - name: force
          - name: image
          - name: cpu_request
          - name: cpu_limit
          - name: memory_request
          - name: memory_limit
          - name: replicas
      outputs:
        parameters:
          - name: job-name
            valueFrom:
              path: /tmp/job-name.txt
      volumes:
        - name: rayjob-template
          configMap:
            name: embeddings-rayjob-template
      script:
        image: alpine/k8s:1.30.4
        command: [sh]
        volumeMounts:
          - name: rayjob-template
            mountPath: /templates
        source: |
          set -e

          # Export variables for envsubst
          export DATA_VERSION="{{inputs.parameters.data_version}}"
          export IMAGE="{{inputs.parameters.image}}"
          export CPU_REQUEST="{{inputs.parameters.cpu_request}}"
          export CPU_LIMIT="{{inputs.parameters.cpu_limit}}"
          export MEMORY_REQUEST="{{inputs.parameters.memory_request}}"
          export MEMORY_LIMIT="{{inputs.parameters.memory_limit}}"
          export REPLICAS="{{inputs.parameters.replicas}}"
          export RUN_LABEL="emb$(date +%Y%m%d%H%M%S)"

          FORCE="{{inputs.parameters.force}}"
          export FORCE_FLAG=""
          [ "$FORCE" = "true" ] && export FORCE_FLAG="--force"

          echo "=========================================="
          echo "Creating RayJob"
          echo "  Label:        ${RUN_LABEL}"
          echo "  Data version: ${DATA_VERSION}"
          echo "  Image:        ${IMAGE}"
          echo "  Force:        ${FORCE_FLAG:-no}"
          echo "=========================================="

          # Substitute variables in template
          envsubst < /templates/rayjob.yaml > /tmp/rayjob.yaml

          echo "Generated YAML:"
          cat /tmp/rayjob.yaml
          echo ""

          # Create the RayJob
          kubectl create -f /tmp/rayjob.yaml

          # Wait for job to appear
          sleep 3
          JOB_NAME=$(kubectl get rayjobs -n mlops -l run=${RUN_LABEL} -o jsonpath='{.items[0].metadata.name}')

          if [ -z "$JOB_NAME" ]; then
            echo "ERROR: Failed to find RayJob with label run=${RUN_LABEL}"
            kubectl get rayjobs -n mlops
            exit 1
          fi

          echo "$JOB_NAME" > /tmp/job-name.txt
          echo "RayJob created: $JOB_NAME"

          # Wait for cluster to be ready
          echo "Waiting for Ray cluster..."
          TIMEOUT=300
          ELAPSED=0
          while [ $ELAPSED -lt $TIMEOUT ]; do
            DEPLOY_STATUS=$(kubectl get rayjob -n mlops $JOB_NAME -o jsonpath='{.status.jobDeploymentStatus}' 2>/dev/null || echo "")

            case "$DEPLOY_STATUS" in
              Running|Complete)
                echo "Ray cluster ready, job is $DEPLOY_STATUS"
                break
                ;;
              Failed)
                echo "ERROR: RayJob deployment failed"
                kubectl describe rayjob -n mlops $JOB_NAME
                kubectl get pods -n mlops -l ray.io/cluster --show-labels
                exit 1
                ;;
              *)
                echo "Waiting... status: ${DEPLOY_STATUS:-pending}"
                sleep 5
                ELAPSED=$((ELAPSED + 5))
                ;;
            esac
          done

          if [ $ELAPSED -ge $TIMEOUT ]; then
            echo "ERROR: Timeout waiting for Ray cluster"
            kubectl describe rayjob -n mlops $JOB_NAME
            exit 1
          fi

          # Get cluster name for finding pods
          CLUSTER_NAME=$(kubectl get rayjob -n mlops $JOB_NAME -o jsonpath='{.status.rayClusterName}')
          echo "Ray cluster: $CLUSTER_NAME"

          # Find head pod and stream its logs (the job runs on head)
          sleep 5
          HEAD_POD=$(kubectl get pods -n mlops -l ray.io/cluster=$CLUSTER_NAME,ray.io/node-type=head -o jsonpath='{.items[0].metadata.name}' 2>/dev/null || echo "")

          if [ -n "$HEAD_POD" ]; then
            echo "Streaming logs from head pod: $HEAD_POD"
            echo "=========================================="
            # Stream logs in background
            kubectl logs -n mlops $HEAD_POD -f 2>/dev/null &
            LOG_PID=$!
          else
            echo "WARNING: Could not find head pod"
          fi

          # Monitor job status until completion
          echo "Monitoring job status..."
          while true; do
            JOB_STATUS=$(kubectl get rayjob -n mlops $JOB_NAME -o jsonpath='{.status.jobStatus}' 2>/dev/null || echo "")
            DEPLOY_STATUS=$(kubectl get rayjob -n mlops $JOB_NAME -o jsonpath='{.status.jobDeploymentStatus}' 2>/dev/null || echo "")

            case "$JOB_STATUS" in
              SUCCEEDED)
                [ -n "$LOG_PID" ] && kill $LOG_PID 2>/dev/null || true
                echo ""
                echo "=========================================="
                echo "SUCCESS: RayJob completed successfully"
                echo "=========================================="
                exit 0
                ;;
              FAILED|STOPPED)
                [ -n "$LOG_PID" ] && kill $LOG_PID 2>/dev/null || true
                echo ""
                echo "=========================================="
                echo "ERROR: RayJob failed with status: $JOB_STATUS"
                echo "=========================================="
                echo ""
                echo "RayJob details:"
                kubectl describe rayjob -n mlops $JOB_NAME
                echo ""
                echo "Head pod logs:"
                [ -n "$HEAD_POD" ] && kubectl logs -n mlops $HEAD_POD --tail=100 2>/dev/null || echo "No head pod"
                exit 1
                ;;
            esac

            # Also check if deployment failed
            if [ "$DEPLOY_STATUS" = "Failed" ]; then
              [ -n "$LOG_PID" ] && kill $LOG_PID 2>/dev/null || true
              echo "ERROR: Deployment failed"
              kubectl describe rayjob -n mlops $JOB_NAME
              exit 1
            fi

            sleep 5
          done

    - name: git-commit-tag
      inputs:
        parameters:
          - name: data_version
          - name: bump_type
          - name: is_automated
      outputs:
        parameters:
          - name: tag
            valueFrom:
              path: /tmp/tag.txt
      volumes:
        - name: git-secret
          secret:
            secretName: data-registry-repo
      script:
        image: alpine/git:latest
        command: [sh]
        volumeMounts:
          - name: git-secret
            mountPath: /mnt/secrets
            readOnly: true
        source: |
          set -e
          echo "" > /tmp/tag.txt

          DATA_VERSION="{{inputs.parameters.data_version}}"
          BUMP_TYPE="{{inputs.parameters.bump_type}}"
          IS_AUTOMATED="{{inputs.parameters.is_automated}}"
          TAG_PREFIX="opencloudhub-readmes-embeddings"

          mkdir -p ~/.ssh
          cat /mnt/secrets/sshPrivateKey > ~/.ssh/id_ed25519
          echo "" >> ~/.ssh/id_ed25519
          chmod 600 ~/.ssh/id_ed25519
          ssh-keyscan github.com >> ~/.ssh/known_hosts 2>/dev/null

          git clone git@github.com:OpenCloudHub/data-registry.git /tmp/repo
          cd /tmp/repo
          git config user.name "Argo Workflow"
          git config user.email "workflow@opencloudhub.org"

          [ "$IS_AUTOMATED" = "true" ] && SUFFIX="-automated" || SUFFIX=""

          LATEST=$(git tag -l "${TAG_PREFIX}-v*" --sort=-version:refname | head -n1)
          if [ -z "$LATEST" ]; then
            VERSION="1.0.0"
          else
            CURRENT=$(echo "$LATEST" | sed "s/${TAG_PREFIX}-v//" | sed 's/-automated//')
            MAJOR=$(echo "$CURRENT" | cut -d. -f1)
            MINOR=$(echo "$CURRENT" | cut -d. -f2)
            PATCH=$(echo "$CURRENT" | cut -d. -f3)
            case "$BUMP_TYPE" in
              major) VERSION="$((MAJOR + 1)).0.0" ;;
              minor) VERSION="${MAJOR}.$((MINOR + 1)).0" ;;
              *) VERSION="${MAJOR}.${MINOR}.$((PATCH + 1))" ;;
            esac
          fi

          NEW_TAG="${TAG_PREFIX}-v${VERSION}${SUFFIX}"

          if git tag -l "$NEW_TAG" | grep -q .; then
            echo "Tag $NEW_TAG exists"
          else
            git tag -a "$NEW_TAG" -m "Embeddings v${VERSION} (source: ${DATA_VERSION})"
            git push origin "$NEW_TAG"
            echo "Created: $NEW_TAG"
          fi

          echo "$NEW_TAG" > /tmp/tag.txt
