apiVersion: argoproj.io/v1alpha1
kind: WorkflowTemplate
metadata:
  name: git-templates
  namespace: mlops
  annotations:
    workflows.argoproj.io/description: "Reusable git operations for data pipelines"
spec:
  serviceAccountName: workflow-executor

  templates:
    # =========================================================================
    # Commit and push with retry/rebase logic
    # =========================================================================
    - name: commit-and-push
      inputs:
        parameters:
          - name: repo_path
            description: "Path to cloned repo"
          - name: files_to_add
            description: "Files/paths to git add (space-separated or glob)"
          - name: commit_message
          - name: branch
            default: "main"
          - name: max_retries
            default: "3"
        artifacts:
          - name: repo
            path: "{{inputs.parameters.repo_path}}"
      outputs:
        parameters:
          - name: committed
            valueFrom:
              path: /tmp/committed.txt
      volumes:
        - name: git-secret
          secret:
            secretName: data-registry-repo
      script:
        image: alpine/git:latest
        command: [sh]
        volumeMounts:
          - name: git-secret
            mountPath: /mnt/secrets
            readOnly: true
        source: |
          set -e
          echo "false" > /tmp/committed.txt

          # Setup SSH
          mkdir -p ~/.ssh
          cat /mnt/secrets/sshPrivateKey > ~/.ssh/id_ed25519
          echo "" >> ~/.ssh/id_ed25519
          chmod 600 ~/.ssh/id_ed25519
          ssh-keyscan github.com >> ~/.ssh/known_hosts 2>/dev/null

          cd "{{inputs.parameters.repo_path}}"

          # Check for changes
          git add {{inputs.parameters.files_to_add}}

          if git diff --cached --quiet; then
            echo "â„¹ï¸  No changes to commit"
            exit 0
          fi

          echo "ðŸ“ Changes detected, committing..."
          git commit -m "{{inputs.parameters.commit_message}}"

          # Push with retry and rebase on conflict
          MAX_RETRIES={{inputs.parameters.max_retries}}
          for attempt in $(seq 1 $MAX_RETRIES); do
            echo "ðŸ”„ Push attempt $attempt/$MAX_RETRIES..."

            if git push origin {{inputs.parameters.branch}}; then
              echo "âœ… Pushed successfully"
              echo "true" > /tmp/committed.txt
              exit 0
            fi

            if [ $attempt -eq $MAX_RETRIES ]; then
              echo "âŒ Failed after $MAX_RETRIES attempts"
              exit 1
            fi

            echo "âš ï¸  Push failed, rebasing..."
            git pull --rebase origin {{inputs.parameters.branch}}
          done

    # =========================================================================
    # Create version tag with semver bump
    # =========================================================================
    - name: create-tag
      inputs:
        parameters:
          - name: repo_path
            description: "Path to cloned repo"
          - name: tag_prefix
            description: "Tag prefix (e.g., 'wine-quality' -> wine-quality-v1.0.0)"
          - name: bump_type
            default: "patch"
            description: "major, minor, or patch"
          - name: is_automated
            default: "false"
            description: "Add -automated suffix to tag"
          - name: message
            default: ""
            description: "Tag message (defaults to '<prefix> v<version>')"
        artifacts:
          - name: repo
            path: "{{inputs.parameters.repo_path}}"
      outputs:
        parameters:
          - name: new_tag
            valueFrom:
              path: /tmp/new_tag.txt
          - name: version
            valueFrom:
              path: /tmp/version.txt
      volumes:
        - name: git-secret
          secret:
            secretName: data-registry-repo
      script:
        image: alpine/git:latest
        command: [sh]
        volumeMounts:
          - name: git-secret
            mountPath: /mnt/secrets
            readOnly: true
        source: |
          set -e
          echo "" > /tmp/new_tag.txt
          echo "" > /tmp/version.txt

          # Setup SSH
          mkdir -p ~/.ssh
          cat /mnt/secrets/sshPrivateKey > ~/.ssh/id_ed25519
          echo "" >> ~/.ssh/id_ed25519
          chmod 600 ~/.ssh/id_ed25519
          ssh-keyscan github.com >> ~/.ssh/known_hosts 2>/dev/null

          cd "{{inputs.parameters.repo_path}}"

          TAG_PREFIX="{{inputs.parameters.tag_prefix}}"
          BUMP_TYPE="{{inputs.parameters.bump_type}}"
          IS_AUTOMATED="{{inputs.parameters.is_automated}}"
          MESSAGE="{{inputs.parameters.message}}"

          # Fetch tags
          git fetch --tags

          # Find latest tag for this prefix
          LATEST=$(git tag -l "${TAG_PREFIX}-v*" --sort=-version:refname | head -n1 || echo "")

          if [ -z "$LATEST" ]; then
            VERSION="1.0.0"
            echo "ðŸ“¦ First version: $VERSION"
          else
            # Extract version, strip -automated suffix if present
            CURRENT=$(echo "$LATEST" | sed "s/${TAG_PREFIX}-v//" | sed 's/-automated//')
            MAJOR=$(echo "$CURRENT" | cut -d. -f1)
            MINOR=$(echo "$CURRENT" | cut -d. -f2)
            PATCH=$(echo "$CURRENT" | cut -d. -f3)

            case "$BUMP_TYPE" in
              major) VERSION="$((MAJOR + 1)).0.0" ;;
              minor) VERSION="${MAJOR}.$((MINOR + 1)).0" ;;
              patch) VERSION="${MAJOR}.${MINOR}.$((PATCH + 1))" ;;
              *) echo "âŒ Invalid bump_type: $BUMP_TYPE"; exit 1 ;;
            esac
            echo "ðŸ“¦ Bumping $BUMP_TYPE: $CURRENT -> $VERSION"
          fi

          # Build tag name
          [ "$IS_AUTOMATED" = "true" ] && SUFFIX="-automated" || SUFFIX=""
          NEW_TAG="${TAG_PREFIX}-v${VERSION}${SUFFIX}"

          # Default message
          [ -z "$MESSAGE" ] && MESSAGE="${TAG_PREFIX} v${VERSION}"

          # Check if tag exists
          if git tag -l "$NEW_TAG" | grep -q "$NEW_TAG"; then
            echo "â„¹ï¸  Tag $NEW_TAG already exists, skipping"
            echo "$NEW_TAG" > /tmp/new_tag.txt
            echo "$VERSION" > /tmp/version.txt
            exit 0
          fi

          # Create and push tag
          git tag -a "$NEW_TAG" -m "$MESSAGE"
          git push origin "$NEW_TAG"

          echo "ðŸ·ï¸  Created tag: $NEW_TAG"
          echo "$NEW_TAG" > /tmp/new_tag.txt
          echo "$VERSION" > /tmp/version.txt

    # =========================================================================
    # Clone repository with SSH setup
    # =========================================================================
    - name: clone-repo
      inputs:
        parameters:
          - name: repo_url
            default: "git@github.com:OpenCloudHub/data-registry.git"
          - name: branch
            default: "main"
          - name: clone_path
            default: "/tmp/repo"
      outputs:
        artifacts:
          - name: repo
            path: "{{inputs.parameters.clone_path}}"
      volumes:
        - name: git-secret
          secret:
            secretName: data-registry-repo
      script:
        image: alpine/git:latest
        command: [sh]
        volumeMounts:
          - name: git-secret
            mountPath: /mnt/secrets
            readOnly: true
        source: |
          set -e

          # Setup SSH
          mkdir -p ~/.ssh
          cat /mnt/secrets/sshPrivateKey > ~/.ssh/id_ed25519
          echo "" >> ~/.ssh/id_ed25519
          chmod 600 ~/.ssh/id_ed25519
          ssh-keyscan github.com >> ~/.ssh/known_hosts 2>/dev/null

          # Clone
          echo "ðŸ“¥ Cloning {{inputs.parameters.repo_url}}..."
          git clone --branch {{inputs.parameters.branch}} {{inputs.parameters.repo_url}} {{inputs.parameters.clone_path}}

          cd {{inputs.parameters.clone_path}}
          git config user.name "Argo Workflow"
          git config user.email "workflow@opencloudhub.org"

          echo "âœ… Cloned to {{inputs.parameters.clone_path}}"

    # =========================================================================
    # Get latest tag for a prefix
    # =========================================================================
    - name: get-latest-tag
      inputs:
        parameters:
          - name: repo_url
            default: "git@github.com:OpenCloudHub/data-registry.git"
          - name: tag_prefix
      outputs:
        parameters:
          - name: latest_tag
            valueFrom:
              path: /tmp/latest_tag.txt
          - name: version
            valueFrom:
              path: /tmp/version.txt
      volumes:
        - name: git-secret
          secret:
            secretName: data-registry-repo
      script:
        image: alpine/git:latest
        command: [sh]
        volumeMounts:
          - name: git-secret
            mountPath: /mnt/secrets
            readOnly: true
        source: |
          set -e
          echo "" > /tmp/latest_tag.txt
          echo "" > /tmp/version.txt

          # Setup SSH
          mkdir -p ~/.ssh
          cat /mnt/secrets/sshPrivateKey > ~/.ssh/id_ed25519
          echo "" >> ~/.ssh/id_ed25519
          chmod 600 ~/.ssh/id_ed25519
          ssh-keyscan github.com >> ~/.ssh/known_hosts 2>/dev/null

          TAG_PREFIX="{{inputs.parameters.tag_prefix}}"

          # List remote tags without full clone
          LATEST=$(git ls-remote --tags {{inputs.parameters.repo_url}} \
            | grep "refs/tags/${TAG_PREFIX}-v" \
            | sed 's/.*refs\/tags\///' \
            | grep -v '\^{}' \
            | sort -V \
            | tail -1 || echo "")

          if [ -z "$LATEST" ]; then
            echo "â„¹ï¸  No tags found for prefix: $TAG_PREFIX"
            exit 0
          fi

          VERSION=$(echo "$LATEST" | sed "s/${TAG_PREFIX}-v//" | sed 's/-automated//')

          echo "$LATEST" > /tmp/latest_tag.txt
          echo "$VERSION" > /tmp/version.txt
          echo "ðŸ“¦ Latest: $LATEST (v$VERSION)"

    # =========================================================================
    # Create and push a version tag with automatic version bumping
    # =========================================================================
    - name: git-tag-version
      inputs:
        parameters:
          - name: tag_prefix
            description: "Tag prefix (e.g., opencloudhub-readmes-embeddings)"
          - name: bump_type
            default: "patch"
            description: "Version bump: major, minor, or patch"
          - name: is_automated
            default: "false"
            description: "Add -automated suffix to tag"
          - name: message
            default: ""
            description: "Tag message"
          - name: repo_url
            default: "git@github.com:OpenCloudHub/data-registry.git"
      outputs:
        parameters:
          - name: tag
            valueFrom:
              path: /tmp/new_tag.txt
          - name: version
            valueFrom:
              path: /tmp/new_version.txt
      volumes:
        - name: git-secret
          secret:
            secretName: data-registry-repo
      script:
        image: alpine/git:latest
        command: [sh]
        volumeMounts:
          - name: git-secret
            mountPath: /mnt/secrets
            readOnly: true
        source: |
          set -e
          echo "" > /tmp/new_tag.txt
          echo "" > /tmp/new_version.txt

          TAG_PREFIX=$(printf '%s' "{{inputs.parameters.tag_prefix}}" | xargs)
          BUMP_TYPE=$(printf '%s' "{{inputs.parameters.bump_type}}" | xargs)
          IS_AUTOMATED=$(printf '%s' "{{inputs.parameters.is_automated}}" | xargs)
          MESSAGE=$(printf '%s' "{{inputs.parameters.message}}" | xargs)
          REPO_URL="{{inputs.parameters.repo_url}}"

          echo "=========================================="
          echo "GIT TAG VERSION"
          echo "  Prefix:    $TAG_PREFIX"
          echo "  Bump:      $BUMP_TYPE"
          echo "  Automated: $IS_AUTOMATED"
          echo "=========================================="

          # Setup SSH
          mkdir -p ~/.ssh
          cat /mnt/secrets/sshPrivateKey > ~/.ssh/id_ed25519
          echo "" >> ~/.ssh/id_ed25519
          chmod 600 ~/.ssh/id_ed25519
          ssh-keyscan github.com >> ~/.ssh/known_hosts 2>/dev/null

          # Clone repo
          git clone "$REPO_URL" /tmp/repo
          cd /tmp/repo
          git config user.name "Argo Workflow"
          git config user.email "workflow@opencloudhub.org"

          # Determine suffix
          SUFFIX=""
          [ "$IS_AUTOMATED" = "true" ] && SUFFIX="-automated"

          # Find latest tag with this prefix
          LATEST=$(git tag -l "${TAG_PREFIX}-v*" --sort=-version:refname | head -n1 || echo "")

          if [ -z "$LATEST" ]; then
            VERSION="1.0.0"
            echo "No existing tags, starting at v1.0.0"
          else
            # Extract version (remove prefix and any suffix)
            CURRENT=$(echo "$LATEST" | sed "s/${TAG_PREFIX}-v//" | sed 's/-automated//')
            MAJOR=$(echo "$CURRENT" | cut -d. -f1)
            MINOR=$(echo "$CURRENT" | cut -d. -f2)
            PATCH=$(echo "$CURRENT" | cut -d. -f3)

            case "$BUMP_TYPE" in
              major)
                VERSION="$((MAJOR + 1)).0.0"
                ;;
              minor)
                VERSION="${MAJOR}.$((MINOR + 1)).0"
                ;;
              *)
                VERSION="${MAJOR}.${MINOR}.$((PATCH + 1))"
                ;;
            esac
            echo "Bumped from $CURRENT to $VERSION ($BUMP_TYPE)"
          fi

          NEW_TAG="${TAG_PREFIX}-v${VERSION}${SUFFIX}"

          # Check if tag already exists
          if git tag -l "$NEW_TAG" | grep -q .; then
            echo "Tag $NEW_TAG already exists, skipping"
            echo "$NEW_TAG" > /tmp/new_tag.txt
            echo "$VERSION" > /tmp/new_version.txt
            exit 0
          fi

          # Create and push tag
          if [ -n "$MESSAGE" ]; then
            git tag -a "$NEW_TAG" -m "$MESSAGE"
          else
            git tag -a "$NEW_TAG" -m "${TAG_PREFIX} v${VERSION}"
          fi

          git push origin "$NEW_TAG"

          echo "$NEW_TAG" > /tmp/new_tag.txt
          echo "$VERSION" > /tmp/new_version.txt

          echo ""
          echo "=========================================="
          echo "SUCCESS: Created tag $NEW_TAG"
          echo "=========================================="
